# 布局计算中的循环依赖问题

## 问题描述

在实现侧边栏 pin 功能时，发现组件宽度异常（158259px），导致侧边栏区域显示为空白。

### 触发场景

1. 用户点击 pin 按钮固定到侧边栏
2. 用户调整浏览器窗口大小（resize）
3. 用户修改 `widthPercentWhenPin` 配置项

## 根本原因

### 错误的计算逻辑

在 `_handleResize` 方法中，使用了**已被 margin 影响过的元素位置**来反推宽度：

```typescript
// ❌ 错误做法
content.style.marginRight = '';  // 清除 margin
const contentRect = content.getBoundingClientRect();
const newWidth = viewportWidth - contentRect.right;  // 用旧位置计算
```

### 为什么会越算越大

**关键问题**：清除 `marginRight` 后，浏览器布局不会立即更新，`getBoundingClientRect()` 拿到的是**旧的、被挤压后的位置**。

#### 数值演变示例

假设初始状态：
- 视口宽度 = 1920px
- 配置百分比 = 30%
- 应有宽度 = 576px

**第 1 次 Pin（正常）**
```
newWidth = 1920 * 30% = 576
content.marginRight = '576px'
content.right = 1920 - 576 = 1344  // 被挤压后的位置
```

**第 1 次 Resize（开始出错）**

用户把窗口拉大到 2000px：
```
content.marginRight = ''  // 清除
contentRect.right = 1344  // ❌ 还是旧值！布局未更新
newWidth = 2000 - 1344 = 656  // 比应有的 600 (30%) 多了 56px
```

**第 2 次 Resize（继续恶化）**

用户再把窗口拉到 2100px：
```
contentRect.right = 1344  // ❌ 仍然是固定值
newWidth = 2100 - 1344 = 756  // 比应有的 630 (30%) 多了 126px
```

**数学公式**
```
错误的宽度 = 当前视口宽度 - 固定的right值
           = 当前视口宽度 - (初始视口宽度 - 初始宽度)
           = 当前视口宽度 - 初始视口宽度 + 初始宽度
```

当视口变大时，这个值会线性增长，最终累积到 158259px 这种离谱的数字。

### 类似问题：top 位置计算

同样的问题也存在于 `contentRect.top` 的使用：

```typescript
// ❌ 可能有延迟
const contentRect = content.getBoundingClientRect();
this.state.element.style.top = `${contentRect.top}px`;
```

虽然不如宽度问题严重，但在某些情况下仍可能导致位置偏移。

## 解决方案

### 核心原则

**不要依赖被动态修改过的元素位置来反推布局参数，而应该直接使用配置值或可靠的属性。**

### 1. 宽度计算：使用配置的百分比

```typescript
// ✅ 正确做法
const newWidth = Math.floor(viewportWidth * this.options.widthPercentWhenPin / 100);

// Pin 到右侧
this.state.element.style.left = `${viewportWidth - newWidth}px`;
this.state.element.style.width = `${newWidth}px`;

// Pin 到左侧
let ribbonWidth = 0;
const ribbon = document.querySelector('.typ-ribbon') as HTMLElement;
if (ribbon) ribbonWidth = ribbon.offsetWidth;

this.state.element.style.left = `${ribbonWidth}px`;
this.state.element.style.width = `${newWidth}px`;
```

**优点**：
- 永远是视口的固定百分比
- 不会累积误差
- 不依赖任何元素的当前状态

### 2. Top 位置：使用 offsetTop

```typescript
// ✅ 正确做法
const contentTop = content.offsetTop;
const modalHeight = viewportHeight - contentTop;

this.state.element.style.top = `${contentTop}px`;
this.state.element.style.height = `${modalHeight}px`;
```

**优点**：
- `offsetTop` 是相对于 offsetParent 的固定值
- 不受 `getBoundingClientRect()` 布局延迟的影响

### 3. 配置项改变时触发重新布局

在 `updateOptions` 方法中，检测 `widthPercentWhenPin` 是否改变：

```typescript
public updateOptions(newOptions: Partial<TocMindmapOptions>) {
  this.options = { ...this.options, ...newOptions };
  this._updateHighlightStyle();

  // ✅ 如果宽度百分比改变且当前处于 pin 状态，立即重新计算布局
  if (newOptions.widthPercentWhenPin !== undefined && 
      (this.state.isPinLeft || this.state.isPinRight)) {
    this._handleResize();
  }

  if (this.isVisible) {
    this._update();
  }
}
```

## 完整修复代码

### _togglePin 方法

```typescript
private _togglePin(side: 'left' | 'right') {
  const content = document.querySelector('#write') as HTMLElement;
  if (!content || !this.state.element) return;

  const isLeft = side === 'left';
  const isPinning = isLeft ? !this.state.isPinLeft : !this.state.isPinRight;

  if (isPinning) {
    // 只在首次固定时记录原始尺寸
    if (!this.state.originModalRect) {
      this.state.originModalRect = this.state.element.getBoundingClientRect();
      this.state.originContentRect = content.getBoundingClientRect();
    }

    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;
    const contentTop = content.offsetTop;  // ✅ 使用 offsetTop
    const modalHeight = viewportHeight - contentTop;
    
    // ✅ 使用配置的百分比计算
    const newWidth = Math.floor(viewportWidth * this.options.widthPercentWhenPin / 100);
    
    let ribbonWidth = 0;
    if (isLeft) {
      const ribbon = document.querySelector('.typ-ribbon') as HTMLElement;
      if (ribbon) ribbonWidth = ribbon.offsetWidth;
    }
    
    const newLeft = isLeft ? ribbonWidth : viewportWidth - newWidth;

    // 设置导图位置
    Object.assign(this.state.element.style, {
      top: `${contentTop}px`,
      left: `${newLeft}px`,
      width: `${newWidth}px`,
      height: `${modalHeight}px`,
      transform: 'none'
    });

    // 调整内容区域
    const marginKey = isLeft ? 'marginLeft' : 'marginRight';
    content.style[marginKey] = `${newWidth}px`;
    
    // ... 其他代码
  }
}
```

### _handleResize 方法

```typescript
private _handleResize = debounce(() => {
  if (!this.state.element) return;

  const content = document.querySelector('#write') as HTMLElement;
  if (!content) return;

  const viewportHeight = window.innerHeight;
  const viewportWidth = window.innerWidth;
  const contentTop = content.offsetTop;  // ✅ 使用 offsetTop
  const modalHeight = viewportHeight - contentTop;
  const newWidth = Math.floor(viewportWidth * this.options.widthPercentWhenPin / 100);  // ✅ 使用百分比

  if (this.state.isPinRight) {
    this.state.element.style.top = `${contentTop}px`;
    this.state.element.style.height = `${modalHeight}px`;
    this.state.element.style.width = `${newWidth}px`;
    this.state.element.style.left = `${viewportWidth - newWidth}px`;
    content.style.marginRight = `${newWidth}px`;
    content.style.marginLeft = '';
  } else if (this.state.isPinLeft) {
    let ribbonWidth = 0;
    const ribbon = document.querySelector('.typ-ribbon') as HTMLElement;
    if (ribbon) ribbonWidth = ribbon.offsetWidth;
    
    this.state.element.style.top = `${contentTop}px`;
    this.state.element.style.height = `${modalHeight}px`;
    this.state.element.style.width = `${newWidth}px`;
    this.state.element.style.left = `${ribbonWidth}px`;
    content.style.marginLeft = `${newWidth}px`;
    content.style.marginRight = '';
  }
}, 100);
```

## 开发指导原则

### 1. 避免循环依赖

当需要计算布局参数时：
- ❌ 不要用已被修改的元素位置来反推参数
- ✅ 直接使用配置值或可靠的属性

### 2. 选择可靠的 DOM 属性

| 场景 | ❌ 避免使用 | ✅ 推荐使用 |
|------|------------|------------|
| 获取元素相对位置 | `getBoundingClientRect()` 在清除样式后 | `offsetTop`, `offsetLeft` |
| 计算宽度/高度 | 依赖其他元素的位置反推 | 配置值 × 视口尺寸 |
| 获取视口尺寸 | - | `window.innerWidth`, `window.innerHeight` |

### 3. 布局更新时机

当配置项改变时，如果影响布局，需要立即触发重新计算：

```typescript
if (newOptions.widthPercentWhenPin !== undefined && isPinned) {
  this._handleResize();
}
```

### 4. 调试技巧

当遇到布局异常时，检查：
1. 是否在清除样式后立即获取位置（布局延迟）
2. 是否用被修改过的元素位置来计算新位置（循环依赖）
3. 计算公式是否依赖配置值而非当前状态

## 相关文件

- `src/components/TocMindmap.ts` - 主要修复位置
- 修复日期：2025-11-04
- 相关 Issue：Pin 后组件宽度异常（158259px）
