# TocMindmap 组件重构计划 (新版)

---

## 1. 重构目标与核心原则

### 1.1. 核心目标

本次重构旨在彻底解决当前 `TocMindmap` 组件在节点路径管理、状态同步和功能实现上的混乱状况。我们将废弃当前手动维护的、基于文本的路径系统，全面转向使用 Markmap 库自身提供的、更稳定、更可靠的原生数据属性，以提升代码的可读性、稳定性和性能，为未来扩展功能打下坚实的基础。

### 1.2. 核心原则

所有重构工作将严格遵循以下准则：

1.  **路径标识**：**唯一**使用 `INode.state.path` (`"0.1.3"` 格式) 作为节点的持久化、唯一的身份标识。废弃任何手动拼接的文本路径。
2.  **折叠状态读取**：折叠状态的读取**唯一**依赖 `INode.payload.fold` 属性。
3.  **折叠状态操作**：以编程方式修改折叠状态，**唯一**使用 `markmap.toggleNode()` API。**禁止**任何“手动修改 `payload.fold` 后调用 `renderData/setData`”的尝试，因其已被证实不可靠。
4.  **索引机制**：使用两个独立的 `Map` 作为连接“文档DOM”和“SVG节点”的**双向索引**，并采用“清空后重建”策略进行维护，以保证数据同步和交互性能。
5.  **数据驱动**：所有操作应以数据为中心。先修改数据（或通过API间接修改），再由 Markmap 库自动更新视图。避免直接操作 DOM。
6.  **权责分离**：`INode.state` 对象视为**只读**的结构/身份信息；`INode.payload` 用于存储交互状态 (`fold`) 和未来的自定义数据。

---

## 2. 核心数据结构与 API 依据

### 2.1. 节点类型 (以最新 `Markmap_API指南.md` 为准)

#### IPureNode (markmap-lib 输出的纯数据节点)

```typescript
// 由 transformer.transform() 生成的纯数据节点
interface IPureNode {
  content: string;
  payload?: {
    [key: string]: unknown;
    fold?: number; // 折叠状态: 0=展开, 1=折叠, 2=递归折叠
  };
  children: IPureNode[];
}
```

#### INode (markmap-view 使用的带状态节点)

```typescript
// 在 markmap-view 内部使用，增加了 state 属性
interface INode extends IPureNode {
  state: INodeState;
  children: INode[];
}

interface INodeState {
  id: number;      // 自增唯一ID
  path: string;    // 点分隔的路径 (如 "0.1.2")
  key: string;     // 基于内容的唯一标识
  depth: number;   // 节点深度
  el: HTMLElement; // 渲染出的 SVG 元素引用
}
```

### 2.2. 核心映射关系 (双向索引)

为了在“文档DOM”和“思维导图SVG”这两个独立世界之间建立高效、双向的关联，我们使用两个独立的 `Map` 作为索引。这是一种用空间换取时间的经典优化，确保了流畅的交互体验。

1.  **`headingElements: Map<string, HTMLElement>`**
    *   **键 (Key)**: `INode.state.path` (e.g., `"0.1.3"`)
    *   **值 (Value)**: 对应在文档中的 `HTMLElement` (标题元素)。
    *   **作用**：实现从“思维导图节点”到“文档标题元素”的 O(1) 快速查找，用于**点击跳转**功能。

2.  **`elementToPath: Map<HTMLElement, string>`**
    *   **键 (Key)**: 文档中的 `HTMLElement` (标题元素)。
    *   **值 (Value)**: 对应节点的 `INode.state.path` (e.g., `"0.1.3"`)。
    *   **作用**：实现从“文档标题元素”到“思维导图节点路径”的 O(1) 快速查找，用于**滚动高亮**功能。

### 2.3. 数据流向图

```
(点击跳转)
SVG Node --[__data__]--> INode.state.path --[headingElements.get()]--> HTMLElement --> scrollIntoView()

(滚动高亮)
Visible HTMLElement --[elementToPath.get()]--> INode.state.path --[querySelector]--> SVG Node --> addHighlightClass()
```

---

## 3. 功能实现与重构详解

本章节整合了原有的“需要修改的方法”和“功能需求与函数调用链路”，以功能为视角，详述重构方案。

### 3.1. 功能一：初始化与数据同步

*   **需求链路**：打开文档 -> 提取标题 -> 解析为 `INode` -> 渲染 SVG -> 建立索引。
*   **重构方案**：
    1.  **`_update()`** 作为主流程，协调以下操作。
    2.  **`_getDocumentHeadings()`**: **(修改)** 此方法仅负责从文档中查询并返回一个 `HTMLElement[]` 数组，不再处理任何路径和映射逻辑。
    3.  调用 `transformer.transform()` 将 Markdown 文本转换为 `IPureNode` 树。
    4.  调用 `markmap.setData(root)` 进行渲染，`markmap-view` 会自动生成带 `state.path` 的 `INode` 树。
    5.  **`_syncMapsAfterRender(root: INode, headings: HTMLElement[])`**: **(新增)** 此方法在 `setData` 后被调用，是数据同步的核心。
        *   接收 `INode` 树根节点和 `HTMLElement` 数组为参数。
        *   **清空旧索引**：`this.headingElements.clear()` 和 `this.elementToPath.clear()`。
        *   **重建新索引**：同时深度优先遍历 `INode` 树和 `HTMLElement` 数组，因为两者顺序一致，所以可以一一对应。在遍历中，用 `node.state.path` 和 `element` 填充两个 Map。
    6.  **`_addNodePath()`**: **(删除)** 此方法完全废弃。

### 3.2. 功能二：点击思维导图节点跳转

*   **需求链路**：用户点击 SVG 节点 -> 触发 `_scrollToHeadingByNode` -> 滚动到文档对应标题。
*   **重构方案**：
    1.  **`_scrollToHeadingByNode(nodeEl: Element)`**: **(修改)**
        *   从 `nodeEl.__data__.state.path` 获取节点路径。
        *   使用 `this.headingElements.get(path)` 直接获取 `HTMLElement`。
        *   调用 `_scrollToElement()` 执行滚动。

### 3.3. 功能三：文档滚动高亮节点

*   **需求链路**：用户滚动文档 -> `_onScroll` 触发 -> `_getCurrentVisibleHeading` 找到可见标题 -> 高亮对应 SVG 节点。
*   **重构方案**：
    1.  **`_getCurrentVisibleHeading()`**: **(修改)** 仅负责找到并返回当前视口中第一个可见的 `HTMLElement`。
    2.  在 `_onScroll` 的处理流中，拿到 `HTMLElement` 后，使用 `this.elementToPath.get(element)` 直接获取 `state.path`。
    3.  使用 `querySelector("["data-path="${path}"]")` 快速找到 SVG 节点并高亮。

### 3.4. 功能四：自动适应视图（聚焦）

*   **需求链路**：触发 `_fitToView` -> 找到当前标题 -> 展开所有被折叠的祖先节点 -> 平移和缩放视图到该节点。
*   **重构方案**：
    1.  **`_fitToView()`**: **(重构)**
        *   获取当前可见的 `HTMLElement`。
        *   通过 `this.elementToPath.get(element)` 拿到 `state.path`。
        *   调用 `await this._ensureNodeVisible(path)` 确保节点可见。
        *   在 `_ensureNodeVisible` resolve 后，执行平移和缩放动画。
    2.  **`_ensureNodeVisible(path: string)`**: **(新增/重构)**
        *   接收目标节点的 `state.path`。
        *   调用 **`_getAncestorPaths(path)` (新增)** 方法，从 `"0.1.2.3"` 计算出祖先路径数组 `["0", "0.1", "0.1.2"]`。
        *   遍历祖先路径，通过 **`_findNodeByStatePath(path)` (新增/重构)** 在 `INode` 树中找到每个祖先的数据节点。
        *   检查节点的 `payload.fold` 状态，如果为 `1` 或 `2`，则调用 `await this.markmap.toggleNode(ancestorNode)` 强制展开。

### 3.5. 功能五：实时更新

*   **需求链路**：`MutationObserver` 监听到文档变化 -> 触发更新流程 -> 重新渲染并保持状态。
*   **重构方案**：
    1.  **`_onContentChange()`** 触发 `_update()`。
    2.  `_update()` 流程与“初始化”完全一致：清空 Map -> 重新扫描 -> 重新渲染 -> 重建 Map。
    3.  **`_preserveFoldState()`**: **(修改)** 此方法逻辑需要调整。在重建 Map 之前，可以先遍历旧的 `INode` 树，将所有被折叠节点的 `state.path` 存入一个 `Set<string>`。在 `_syncMapsAfterRender` 重建 Map 的过程中，如果一个新节点的 `state.path` 存在于这个 `Set` 中，就将其 `payload.fold` 设为 `1`。

---

## 4. 方法变更清单

*   **❌ 删除**
    *   `_addNodePath()`
*   **🔄 修改/重构**
    *   `_update()`: 调整调用流程。
    *   `_getDocumentHeadings()`: 简化为只返回 `HTMLElement[]`。
    *   `_scrollToHeadingByNode()`: 改为使用 `state.path` 和 `headingElements` Map。
    *   `_getCurrentVisibleHeading()`: 简化为只返回 `HTMLElement`。
    *   `_fitToView()`: 引入 `_ensureNodeVisible` 异步调用。
    *   `_preserveFoldState()`: 改为基于 `state.path` 的 `Set` 来恢复状态。
    *   `_findNodeByPath()` (旧): 重命名为 `_findDOMNodeByStatePath()`。
    *   `_findDataNodeByPath()` (旧): 重命名为 `_findNodeByStatePath()`。
*   **➕ 新增**
    *   `_syncMapsAfterRender()`: 核心的数据索引同步方法。
    *   `_ensureNodeVisible()`: 异步展开祖先节点的核心功能。
    *   `_getAncestorPaths()`: `state.path` 的辅助处理函数。

---

## 5. 关键技术决策

1.  **为何使用 `state.path` 作为唯一标识？**
    *   **官方性与唯一性**：由 Markmap 库自动生成，基于节点位置，绝对唯一，无重名冲突风险。
    *   **DOM 同步**：Markmap 会自动将 `state.path` 作为 `data-path` 属性写入 SVG 节点，便于快速查询。
    *   **零维护成本**：无需任何手动拼接或维护逻辑。

2.  **为何使用两个 Map 而不是一个 `BiMap` 类？**
    *   为了保持实现的直接和简洁，避免引入新的自定义类。使用两个标准 `Map` 的模式功能上完全满足需求，且对于其他开发者来说更容易理解和维护。

3.  **为何在实时更新时“重建”而不是“修补”索引？**
    *   **健壮性**：文档的任何微小变动（如增删一个标题）都可能导致大量节点的 `state.path` 发生改变。尝试计算差异并“修补”索引，逻辑极其复杂且容易出错。
    *   **简单高效**：“清空并重建”的逻辑简单清晰，不易出错。对于现代 JavaScript 引擎，重建数千个 Map 条目的性能开销远低于复杂 diff 算法的开销，完全能满足实时交互的需求。

4.  **为何必须使用 `toggleNode()` 展开节点？**
    *   **可靠性**：根据项目历史实践，这是唯一被验证能 100% 可靠触发节点（尤其是在 macOS 的 WKWebView 环境下）折叠/展开动画并更新视图的 API。
    *   **封装性**：`toggleNode()` 封装了所有必要的内部状态变更和渲染调用，直接使用它可以避免我们关心底层实现的复杂性。

---

## 6. 测试要点与用例设计

### 功能测试
- [ ] **点击跳转**: 点击深层、浅层、重名标题的节点，都能准确跳转。
- [ ] **滚动高亮**: 在文档中滚动，思维导图中的对应节点能被准确、快速地高亮。
- [ ] **适应视图**:
    - [ ] 对一个当前可见的节点，能平滑聚焦。
    - [ ] 对一个被直接折叠的节点，能自动展开其父节点并聚焦。
    - [ ] 对一个在深层折叠分支中的节点，能自动**逐级展开**所有祖先并聚焦。
- [ ] **实时更新**:
    - [ ] 增、删、改标题后，思维导图能正确更新。
    - [ ] 更新后，上述所有功能（跳转、高亮、聚焦）依然正常。
    - [ ] 更新时，用户的折叠状态能被正确保留。

### 边界情况
- [ ] 文档无标题时，插件不报错，并显示空状态。
- [ ] 标题层级不连续时（如 H1 直接到 H3），结构依然正确。
- [ ] 快速、连续地编辑文档内容，插件不会因频繁更新而崩溃（得益于防抖）。

---

## 7. 迁移检查清单

1.  **[ ] 备份**：备份 `TocMindmap.ts` 文件。
2.  **[ ] 类型与状态**：
    *   删除 `HeadingInfo` 类型定义。
    *   将 `state.headingsMap` 修改为 `state.headingElements: Map<string, HTMLElement>`。
    *   新增 `state.elementToPath: Map<HTMLElement, string>`。
3.  **[ ] 新增方法**：
    *   实现 `_syncMapsAfterRender()`。
    *   实现 `_ensureNodeVisible()`。
    *   实现 `_getAncestorPaths()`。
4.  **[ ] 修改与重构方法**：
    *   按照方案逐个修改 `_update`, `_getDocumentHeadings`, `_scrollToHeadingByNode` 等方法。
    *   重命名 `_findNodeByPath` 和 `_findDataNodeByPath`。
5.  **[ ] 删除方法**：
    *   删除 `_addNodePath` 的定义和所有调用。
6.  **[ ] 测试验证**：
    *   按照“测试要点”逐项验证所有功能和边界情况。
7.  **[ ] 代码审查**：确保所有修改都符合新计划，无遗漏。
