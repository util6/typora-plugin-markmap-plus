# 固定到右侧功能实现原理

## 概述

"固定到右侧"功能的核心思路是：**通过修改 Typora 的内容区域（#write）的宽度和位置，为导图窗口腾出空间，而不是让导图窗口覆盖在内容区域之上**。

## 核心实现思路

### 1. 空间分配策略

固定到右侧时，将编辑器的可视区域分为两部分：
- **左侧**：缩小后的内容区域（#write）
- **右侧**：新开辟的导图窗口区域

### 2. 关键 DOM 元素

```javascript
entities: {
    content: document.querySelector('#write'),  // Typora 内容区域
    modal: document.querySelector('#plugin-markmap'),  // 导图窗口
    gripRight: document.querySelector('.plugin-markmap-grip-right')  // 右侧调整手柄
}
```

## 详细实现步骤

### 第一步：记录原始尺寸

在执行固定操作前，需要记录原始的窗口和内容区域尺寸，以便恢复：

```javascript
pinUtils: {
    isPinRight: false,  // 是否已固定到右侧
    originModalRect: null,  // 导图窗口原始位置尺寸
    originContentRect: null,  // 内容区域原始位置尺寸
    
    recordRects: () => {
        if (!this.entities.modal.classList.contains("pinned-window")) {
            this.pinUtils.originModalRect = this.entities.modal.getBoundingClientRect()
            this.pinUtils.originContentRect = this.entities.content.getBoundingClientRect()
        }
    }
}
```

### 第二步：计算新的布局尺寸

```javascript
pinRight = (fit = true) => {
    this.pinUtils.isPinRight = !this.pinUtils.isPinRight
    
    if (this.pinUtils.isPinRight) {
        // 记录原始尺寸
        this.pinUtils.recordRects()
        
        // 获取内容区域的原始尺寸
        const { top, height, width, right } = this.pinUtils.originContentRect
        
        // 计算导图窗口的宽度（配置的百分比）
        const newWidth = width * this.config.WIDTH_PERCENT_WHEN_PIN_RIGHT / 100
        
        // 导图窗口的新位置和尺寸
        modalRect = { 
            top, 
            height, 
            width: newWidth, 
            left: right - newWidth  // 从右边界向左偏移
        }
        
        // 内容区域的新宽度和位置
        contentRight = right - newWidth + "px"
        contentWidth = width - newWidth + "px"
        writeWidth = "initial"
    }
}
```

### 第三步：应用新的布局

```javascript
// 1. 设置导图窗口的位置和尺寸
this._setModalRect(modalRect)

// 2. 修改内容区域的样式，为导图腾出空间
this.entities.content.style.right = contentRight
this.entities.content.style.width = contentWidth
this.utils.entities.eWrite.style.width = writeWidth

// 3. 添加固定状态的样式类
this._setPinStyles(false)
```

### 第四步：添加调整手柄

固定后，在导图窗口左侧添加一个可拖动的手柄，允许用户调整宽度：

```javascript
// HTML 结构
<div class="plugin-markmap-grip-right plugin-common-hidden"></div>

// CSS 样式
.plugin-markmap-grip-right {
    position: absolute;
    top: 0;
    left: -5px;  // 位于窗口左边缘
    width: 10px;
    height: 100%;
    cursor: ew-resize;  // 左右调整光标
}
```

### 第五步：实现宽度调整

```javascript
const whenPinRight = () => {
    let contentStartRight = 0
    let contentStartWidth = 0
    let modalStartLeft = 0
    let contentMaxRight = 0
    
    const onMouseDown = () => {
        this._cleanTransition()
        
        const contentRect = this.entities.content.getBoundingClientRect()
        contentStartRight = contentRect.right
        contentStartWidth = contentRect.width
        
        const modalRect = this.entities.modal.getBoundingClientRect()
        modalStartLeft = modalRect.left
        contentMaxRight = modalRect.right - modalMinWidth
    }
    
    const onMouseMove = (deltaX, deltaY) => {
        deltaX = -deltaX  // 反转方向
        deltaY = -deltaY
        
        let newContentRight = contentStartRight - deltaX
        if (newContentRight > contentMaxRight) {
            deltaX = contentStartRight - contentMaxRight
        }
        
        // 同时调整内容区域和导图窗口
        this.entities.content.style.width = contentStartWidth - deltaX + "px"
        this.entities.modal.style.left = modalStartLeft - deltaX + "px"
        
        return { deltaX, deltaY }
    }
    
    this.utils.resizeElement({
        targetEle: this.entities.gripRight,
        resizeEle: this.entities.modal,
        resizeWidth: true,
        resizeHeight: false,
        onMouseDown,
        onMouseMove,
        onMouseUp
    })
}
```

## 关键 API 和方法

### 1. getBoundingClientRect()
- **作用**：获取元素相对于视口的位置和尺寸信息（原生 DOM API）
- **返回**：DOMRect 对象 `{ x, y, width, height, left, top, right, bottom }`
- **特点**：
  - 返回的坐标是相对于浏览器视口的，不是相对于文档
  - `left/top` 等同于 `x/y`
  - `right = left + width`，`bottom = top + height`
  - 包含 padding 和 border，但不包含 margin
- **示例**：
  ```javascript
  const rect = element.getBoundingClientRect()
  console.log(rect.width)  // 元素宽度（包含 padding + border）
  console.log(rect.left)   // 元素左边缘距离视口左边的距离
  ```

### 2. getComputedStyle()
- **作用**：获取元素所有计算后的 CSS 属性值（原生 DOM API）
- **语法**：`window.getComputedStyle(element)` 或 `document.defaultView.getComputedStyle(element)`
- **返回**：CSSStyleDeclaration 对象，包含所有 CSS 属性的计算值
- **特点**：
  - 返回的是最终计算后的值，不是原始 CSS 值
  - 只读，不能用于设置样式
  - 包含继承的样式和浏览器默认样式
- **示例**：
  ```javascript
  const { width, height } = window.getComputedStyle(element)
  const modalMinWidth = parseFloat(width) || 90  // 转换为数字
  ```

### 3. style 属性修改
- `element.style.width`：设置元素宽度
- `element.style.right`：设置元素右边距
- `element.style.left`：设置元素左边距
- `Object.assign(element.style, {...})`：批量设置样式

### 3. classList 操作
- `classList.contains()`：检查是否包含某个类
- `classList.toggle()`：切换类的存在状态
- `classList.add()`/`classList.remove()`：添加/移除类

### 3. classList 操作
- `classList.contains(className)`：检查是否包含某个类
- `classList.toggle(className, force?)`：切换类的存在状态
- `classList.add(className)`：添加类
- `classList.remove(className)`：移除类

### 4. 鼠标事件 API
- **事件类型**：
  - `mousedown`：鼠标按下
  - `mousemove`：鼠标移动
  - `mouseup`：鼠标释放
- **事件对象属性**：
  - `ev.clientX`：鼠标相对于视口的 X 坐标
  - `ev.clientY`：鼠标相对于视口的 Y 坐标
  - `ev.stopPropagation()`：阻止事件冒泡
  - `ev.preventDefault()`：阻止默认行为
- **示例**：
  ```javascript
  element.addEventListener("mousedown", ev => {
      const startX = ev.clientX
      const startY = ev.clientY
      
      const onMouseMove = ev => {
          const deltaX = ev.clientX - startX
          const deltaY = ev.clientY - startY
          // 根据偏移量调整元素位置
      }
      
      document.addEventListener("mousemove", onMouseMove)
      document.addEventListener("mouseup", () => {
          document.removeEventListener("mousemove", onMouseMove)
      })
  })
  ```

### 5. requestAnimationFrame()
- **作用**：在浏览器下次重绘前执行回调，优化动画性能
- **特点**：
  - 自动与浏览器刷新率同步（通常 60fps）
  - 页面不可见时会暂停，节省资源
  - 比 setTimeout/setInterval 更流畅
- **示例**：
  ```javascript
  function mousemove(e) {
      requestAnimationFrame(() => {
          element.style.left = e.clientX + "px"
          element.style.top = e.clientY + "px"
      })
  }
  ```

### 6. 自定义工具方法
- `this.utils.resizeElement()`：封装的元素调整大小功能
- `this.utils.toggleInvisible()`：切换元素可见性

## 响应式处理

当侧边栏切换或窗口大小改变时，需要重新计算位置：

```javascript
const repositioning = () => {
    if (!this.mm) return
    
    const isFullScreen = fullScreen.getAttribute("action") === "shrink"
    if (!this.pinUtils.isPinTop && !this.pinUtils.isPinRight && !isFullScreen) return
    
    const contentRect = content.getBoundingClientRect()
    const modalRect = modal.getBoundingClientRect()
    const { originContentRect } = this.pinUtils
    
    let newModalRect, newContentRect
    
    if (this.pinUtils.isPinRight) {
        // 重新计算固定到右侧时的位置
        newModalRect = new DOMRect(
            contentRect.right,  // 从内容区域右边界开始
            modalRect.y, 
            modalRect.right - contentRect.right,  // 保持原有宽度
            modalRect.height
        )
        newContentRect = new DOMRect(
            contentRect.x, 
            originContentRect.y, 
            originContentRect.right - contentRect.left, 
            originContentRect.height
        )
    }
    
    this.pinUtils.recordContentRect(newContentRect)
    this._setModalRect(newModalRect)
}

// 监听事件
eventHub.addEventListener(eventHub.eventType.afterToggleSidebar, repositioning)
eventHub.addEventListener(eventHub.eventType.afterSetSidebarWidth, repositioning)
```

## CSS 样式配合

```css
#plugin-markmap {
    display: flex;
    flex-direction: row;
    transition: all 0.8s ease 0s;
    user-select: none;
    min-width: 120px;
    min-height: 120px;
    border-radius: 8px;
}

/* 固定状态下移除阴影 */
#plugin-markmap.pinned-window {
    box-shadow: none;
}

/* 非固定状态下，头部可拖动 */
#plugin-markmap:not(.pinned-window) .plugin-markmap-header {
    cursor: move;
}
```

## 取消固定的恢复逻辑

```javascript
// 取消固定时恢复原始状态
if (!this.pinUtils.isPinRight) {
    modalRect = this.pinUtils.originModalRect
    contentRight = ""
    contentWidth = ""
    writeWidth = ""
}

this._setModalRect(modalRect)
this._setPinStyles(false)
this.entities.content.style.right = contentRight
this.entities.content.style.width = contentWidth
this.utils.entities.eWrite.style.width = writeWidth
```

## 配置项

```javascript
config: {
    // 固定到右侧时，导图窗口占内容区域宽度的百分比
    WIDTH_PERCENT_WHEN_PIN_RIGHT: 30  // 默认 30%
}
```

## 总结

固定到右侧功能的实现要点：

1. **空间重新分配**：通过修改 `#write` 的 `width` 和 `right` 属性，为导图窗口腾出空间
2. **位置计算**：导图窗口的 `left` 位置 = 内容区域的 `right` - 导图窗口宽度
3. **状态管理**：使用 `pinUtils` 对象记录固定状态和原始尺寸
4. **响应式更新**：监听侧边栏和窗口变化事件，动态调整布局
5. **用户交互**：提供调整手柄，允许用户自定义宽度分配
6. **样式配合**：使用 CSS 类 `pinned-window` 区分固定和浮动状态

这种实现方式的优势是**不会遮挡内容**，用户可以同时查看文档和导图，提供更好的用户体验。


## 技术实现细节

### resizeElement() 工具函数实现

封装的拖拽调整元素大小功能，位于 `plugin/global/core/utils/index.js`：

```javascript
static resizeElement = ({
    targetEle,      // 触发拖拽的目标元素（如调整手柄）
    resizeEle,      // 需要调整大小的元素
    resizeWidth = true,   // 是否调整宽度
    resizeHeight = true,  // 是否调整高度
    onMouseDown = null,   // 鼠标按下回调
    onMouseMove = null,   // 鼠标移动回调
    onMouseUp = null,     // 鼠标释放回调
}) => {
    let startX, startY, startWidth, startHeight
    
    targetEle.addEventListener("mousedown", ev => {
        // 使用 getComputedStyle 获取元素当前的计算样式
        const { width, height } = document.defaultView.getComputedStyle(resizeEle)
        startX = ev.clientX
        startY = ev.clientY
        startWidth = parseFloat(width)
        startHeight = parseFloat(height)
        
        if (onMouseDown) {
            onMouseDown(startX, startY, startWidth, startHeight)
        }
        
        document.addEventListener("mousemove", mousemove)
        document.addEventListener("mouseup", mouseup)
        ev.stopPropagation()
        ev.preventDefault()
    }, true)
    
    function mousemove(e) {
        // 使用 requestAnimationFrame 优化性能
        requestAnimationFrame(() => {
            let deltaX = e.clientX - startX
            let deltaY = e.clientY - startY
            
            // 允许自定义回调修改偏移量（如限制最小/最大值）
            if (onMouseMove) {
                const result = onMouseMove(deltaX, deltaY) || {}
                deltaX = result.deltaX || deltaX
                deltaY = result.deltaY || deltaY
            }
            
            if (resizeWidth) {
                resizeEle.style.width = startWidth + deltaX + "px"
            }
            if (resizeHeight) {
                resizeEle.style.height = startHeight + deltaY + "px"
            }
        })
    }
    
    function mouseup() {
        document.removeEventListener("mousemove", mousemove)
        document.removeEventListener("mouseup", mouseup)
        if (onMouseUp) {
            onMouseUp()
        }
    }
}
```

### dragElement() 工具函数实现

封装的拖拽移动元素功能：

```javascript
static dragElement = ({
    targetEle,   // 触发拖拽的目标元素（如标题栏）
    moveEle,     // 需要移动的元素
    onCheck = null,      // 检查是否允许拖拽
    onMouseDown = null,  // 鼠标按下回调
    onMouseMove = null,  // 鼠标移动回调
    onMouseUp = null,    // 鼠标释放回调
}) => {
    targetEle.addEventListener("mousedown", ev => {
        if (onCheck && !onCheck(ev)) return
        
        ev.stopPropagation()
        // 使用 getBoundingClientRect 获取元素位置
        const { left, top } = moveEle.getBoundingClientRect()
        const shiftX = ev.clientX - left  // 计算鼠标相对元素的偏移
        const shiftY = ev.clientY - top
        
        if (onMouseDown) {
            onMouseDown()
        }
        
        const _onMouseMove = ev => {
            ev.stopPropagation()
            ev.preventDefault()
            requestAnimationFrame(() => {
                if (onMouseMove) {
                    onMouseMove()
                }
                // 根据鼠标位置和偏移量计算新位置
                moveEle.style.left = ev.clientX - shiftX + "px"
                moveEle.style.top = ev.clientY - shiftY + "px"
            })
        }
        
        const _onMouseUp = ev => {
            if (onMouseUp) {
                onMouseUp()
            }
            ev.stopPropagation()
            ev.preventDefault()
            document.removeEventListener("mousemove", _onMouseMove)
            document.removeEventListener("mouseup", _onMouseUp)
        }
        
        document.addEventListener("mouseup", _onMouseUp)
        document.addEventListener("mousemove", _onMouseMove)
    })
    targetEle.ondragstart = () => false  // 禁用浏览器默认拖拽行为
}
```

### 关键技术点说明

1. **纯原生 API 实现**：不依赖任何第三方库，使用原生 DOM API
2. **性能优化**：使用 `requestAnimationFrame()` 确保动画流畅，与浏览器刷新率同步
3. **事件委托**：在 `document` 上监听 `mousemove` 和 `mouseup`，避免鼠标移出元素时事件丢失
4. **精确计算**：通过 `getBoundingClientRect()` 获取精确的元素位置和尺寸
5. **回调机制**：提供 `onMouseDown`、`onMouseMove`、`onMouseUp` 回调，允许自定义行为
6. **边界限制**：在 `onMouseMove` 回调中可以限制最小/最大尺寸

### DOMRect 对象详解

`getBoundingClientRect()` 返回的 DOMRect 对象包含以下属性：

```javascript
{
    x: 100,        // 元素左上角的 X 坐标（相对于视口）
    y: 50,         // 元素左上角的 Y 坐标（相对于视口）
    width: 300,    // 元素宽度（包含 padding + border）
    height: 200,   // 元素高度（包含 padding + border）
    left: 100,     // 等同于 x
    top: 50,       // 等同于 y
    right: 400,    // left + width
    bottom: 250    // top + height
}
```

**注意事项**：
- 坐标是相对于浏览器视口的，不是相对于文档
- 包含 padding 和 border，但不包含 margin
- 滚动页面时，这些值会改变
- 返回的是只读对象，不能直接修改

### 样式过渡控制

在拖拽和调整大小时，需要临时禁用 CSS 过渡效果，避免卡顿：

```javascript
// 禁用过渡
_cleanTransition = () => this.entities.modal.style.transition = "none"

// 恢复过渡
_rollbackTransition = () => this.entities.modal.style.transition = ""
```

在 `onMouseDown` 时调用 `_cleanTransition()`，在 `onMouseUp` 时调用 `_rollbackTransition()`。
