# 固定到右侧功能实现方案

## 实现步骤

### 1. 添加配置选项

在 `TocMindmapOptions` 接口中添加：

```typescript
/** 固定到右侧时，导图窗口占内容区域宽度的百分比 */
widthPercentWhenPinRight: number
```

在 `DEFAULT_TOC_OPTIONS` 中添加默认值：

```typescript
widthPercentWhenPinRight: 30,
```

### 2. 扩展组件状态

在 `state` 对象中添加固定状态管理：

```typescript
private state = {
  // ... 现有属性
  /** 是否固定到右侧 */
  isPinRight: false,
  /** 导图窗口原始位置尺寸 */
  originModalRect: null as DOMRect | null,
  /** 内容区域原始位置尺寸 */
  originContentRect: null as DOMRect | null,
}
```

### 3. 修改 HTML 模板

在 `COMPONENT_TEMPLATE` 中添加固定按钮（不需要额外的调整手柄元素）：

```typescript
const COMPONENT_TEMPLATE = `
  <div class="markmap-toc-header">
    <span class="markmap-toc-title"></span>
    <div class="markmap-toc-buttons">
      <button class="markmap-toc-btn" data-action="pin-right" title="固定到右侧">📍</button>
      <button class="markmap-toc-btn" data-action="dock-left" title="嵌入侧边栏">📌</button>
      <button class="markmap-toc-btn" data-action="zoom-in" title="放大">🔍+</button>
      <button class="markmap-toc-btn" data-action="zoom-out" title="缩小">🔍-</button>
      <button class="markmap-toc-btn" data-action="fit" title="适应视图">🎯</button>
      <button class="markmap-toc-btn" data-action="export" title="导出">💾</button>
      <button class="markmap-toc-btn" data-action="close" title="关闭">×</button>
    </div>
  </div>
  <div class="markmap-toc-content">
    <svg class="markmap-svg"></svg>
  </div>
`;
```

### 4. 添加样式

在 `COMPONENT_STYLE` 中添加：

```css
/* 固定状态样式 */
.markmap-toc-modal.pinned-right {
  box-shadow: none;
  border-radius: 0;
  border-right: none;
}
```

### 5. 实现固定逻辑（使用 InteractJS）

添加 `_pinRight` 方法：

```typescript
private _pinRight() {
  const content = document.querySelector('#write') as HTMLElement;
  if (!content || !this.state.element) return;

  this.state.isPinRight = !this.state.isPinRight;

  if (this.state.isPinRight) {
    // 记录原始尺寸
    this.state.originModalRect = this.state.element.getBoundingClientRect();
    this.state.originContentRect = content.getBoundingClientRect();

    const { top, height, width, right } = this.state.originContentRect;
    const newWidth = width * this.options.widthPercentWhenPinRight / 100;

    // 设置导图位置
    Object.assign(this.state.element.style, {
      top: `${top}px`,
      left: `${right - newWidth}px`,
      width: `${newWidth}px`,
      height: `${height}px`,
      transform: 'none'
    });

    // 调整内容区域
    content.style.right = `${newWidth}px`;
    content.style.width = `${width - newWidth}px`;

    this.state.element.classList.add('pinned-right');
    
    // 重新配置 InteractJS：禁用拖动，只允许左边缘调整
    interact(this.state.element)
      .draggable(false)
      .resizable({
        edges: { left: true, right: false, top: false, bottom: false },
        listeners: {
          move: (event) => {
            const target = event.target;
            const newWidth = event.rect.width;
            
            // 同步调整 #write 的宽度
            const contentWidth = this.state.originContentRect!.width - newWidth;
            content.style.width = `${contentWidth}px`;
            content.style.right = `${newWidth}px`;
            
            // 更新导图位置
            target.style.width = `${newWidth}px`;
            target.style.left = `${event.rect.left}px`;
            target.style.transform = 'none';
          }
        }
      });
  } else {
    // 恢复原始状态
    if (this.state.originModalRect) {
      const { left, top, width, height } = this.state.originModalRect;
      Object.assign(this.state.element.style, {
        left: `${left}px`,
        top: `${top}px`,
        width: `${width}px`,
        height: `${height}px`
      });
    }

    content.style.right = '';
    content.style.width = '';

    this.state.element.classList.remove('pinned-right');
    
    // 恢复 InteractJS 原始配置
    this._setupInteractJS();
  }
}
```

### 6. 绑定事件

在 `_attachEventListeners` 方法中添加：

```typescript
case 'pin-right':
  this._pinRight();
  break;
```

### 7. 响应式处理（可选）

监听窗口大小变化，在固定状态下重新计算布局：

```typescript
private _handleResize = debounce(() => {
  if (this.state.isPinRight && this.state.element) {
    const content = document.querySelector('#write') as HTMLElement;
    if (!content) return;

    const contentRect = content.getBoundingClientRect();
    const modalRect = this.state.element.getBoundingClientRect();

    this.state.element.style.top = `${contentRect.top}px`;
    this.state.element.style.height = `${contentRect.height}px`;
    this.state.element.style.left = `${contentRect.right - modalRect.width}px`;
  }
}, 100);

// 在 show() 方法中添加监听
window.addEventListener('resize', this._handleResize);

// 在 hide() 方法中移除监听
window.removeEventListener('resize', this._handleResize);
```

## 核心要点

1. **空间重新分配**：通过修改 `#write` 的 `width` 和 `right` 属性为导图腾出空间
2. **位置计算**：导图的 `left = content.right - 导图宽度`
3. **状态管理**：记录原始尺寸用于恢复
4. **复用 InteractJS**：重新配置 InteractJS 实现宽度调整，无需手动处理鼠标事件
5. **同步调整**：在 InteractJS 的 `move` 事件中同步调整两个元素的宽度

## 关键 API

- `getBoundingClientRect()`：获取元素精确位置和尺寸
- `interact().resizable()`：配置 InteractJS 调整大小功能
- `Object.assign()`：批量设置样式
- `classList.add/remove()`：切换 CSS 类

## 实现优势

- **代码最简**：不需要额外的 DOM 元素和手动事件处理
- **复用逻辑**：利用 InteractJS 的边缘检测、事件处理等功能
- **不遮挡内容**：用户可同时查看文档和导图
- **动态调整**：支持拖动左边缘调整宽度分配
- **响应式布局**：适应窗口变化
