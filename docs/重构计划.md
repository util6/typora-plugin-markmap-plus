# TocMindmap 组件重构计划

## 重构目标

本次重构旨在彻底解决当前 `TocMindmap` 组件在节点路径管理、状态同步和功能实现上的混乱状况。我们将废弃当前手动维护的、基于文本的路径系统，全面转向使用 Markmap 库自身提供的、更稳定、更可靠的原生数据属性。

**最终目标：** 提升代码的可读性、稳定性和性能，为未来扩展功能打下坚实的基础。

## 核心问题

当前代码错误地将文本路径（如 `"第一章\n第一节"`）存储为节点路径，但 markmap 的 `state.path` 实际是由节点 ID 组成的数字路径（如 `"0.1.3"`），由 markmap-view 自动生成和管理。

## 重构原则



所有重构工作将严格遵循以下准则：

1.  **路径标识**：**唯一**使用 `INode.state.path` (`"0.1.3"` 格式) 作为节点的持久化、唯一的身份标识。废弃任何手动拼接的文本路径。
2.  **折叠状态**：折叠状态的读取**唯一**依赖 `INode.payload.fold` 属性。
3.  **折叠操作**：以编程方式修改折叠状态，**唯一**使用 `markmap.toggleNode()` API。**禁止**任何“手动修改 `payload.fold` 后调用 `renderData/setData`”的尝试，因其已被证实不可靠。
4.  **数据驱动**：所有操作应以数据为中心。先修改数据（或通过API间接修改），再由 Markmap 库自动更新视图。避免直接操作 DOM。







---

## API 依据说明

#### IPureNode (markmap-lib 输出的纯数据节点)

```typescript
// 由 transformer.transform() 生成的纯数据节点
interface IPureNode {
  content: string;           // 节点的 HTML 内容
  payload?: {
    [key: string]: unknown;
    fold?: number;           // 折叠状态: 0=展开, 1=折叠, 2=递归折叠
  };
  children: IPureNode[];     // 子节点数组
}
```

#### INode (markmap-view 使用的带状态节点)

```typescript
// 在 markmap-view 内部使用，增加了 state 属性
interface INode extends IPureNode {
  state: INodeState;
  children: INode[];
}

interface INodeState {
  id: number;                // 自增唯一ID
  path: string;              // 点分隔的路径 (如 "0.1.2")
  key: string;               // 基于内容的唯一标识
  depth: number;             // 节点深度
  el: HTMLElement;           // DOM 元素引用
  // ... 其他渲染相关的临时坐标和尺寸信息
}
```

### 3. state.path 的生成逻辑



```javascript
// markmap-view 内部实现
a.state.id = i;  // 自增 ID: 0, 1, 2, 3...

// path 由父节点 path + 当前节点 id 组成
a.state.path = [
  parentNode?.state?.path,  // 父节点的 path
  a.state.id                // 当前节点的 id
].filter(Boolean).join(".")
```

**示例**：
```
根节点:           state.id = 0,  state.path = "0"
├─ 第1个子节点:    state.id = 1,  state.path = "0.1"
├─ 第2个子节点:    state.id = 2,  state.path = "0.2"
   └─ 孙子节点:    state.id = 3,  state.path = "0.2.3"
```

**关键理解**：
- `state.path` 是数字路径，不是文本路径
- 由 markmap-view 自动生成，不应手动修改
- 可作为节点的唯一标识符使用

### 4. 工作流程（来自 Markmap_API指南.md）

```typescript
// 1. markmap-lib: Markdown 文本 → 树形数据
const transformer = new Transformer();
const { root } = transformer.transform(markdown);

// 2. markmap-view: 树形数据 → SVG 渲染
const mm = Markmap.create('#svg', options, root);
```

**关键理解**：
- markmap-lib 只负责解析 Markdown 标题，生成 `INode` 树
- markmap-view 负责渲染和交互，自动添加 `state` 字段
- 两个库之间通过 `INode` 数据结构传递信息

### 5. 重构方案的 API 使用

基于以上理解，重构方案的核心改动：

| 操作 | 错误做法 | 正确做法 | API 依据 |
|------|---------|---------|---------|
| 节点标识 | 手动构建文本路径 | 使用 `state.path` | `INode.state.path` 由 markmap-view 生成 |
| 存储自定义数据 | 覆盖 `state.path` | 使用 `payload` | `INode.payload` 是用户扩展字段 |
| 查找节点 | 遍历文本路径 | 通过 `state.path` 查找 | `state.path` 是唯一标识符 |
| 展开节点 | 手动操作 DOM | 调用 `markmap.toggleNode()` | markmap-view 提供的实例方法 |
| 更新数据 | 重新创建实例 | 调用 `markmap.setData()` | 保持折叠状态和视图位置 |







## 二、类型定义修改

### `HeadingInfo` 类型

**当前定义**：
```typescript
type HeadingInfo = {
  level: number;
  text: string;
  id: string;
  index: number;
  path: string;        // ← 删除此字段
  element: HTMLElement;
};
```

**修改后**：
```typescript
type HeadingInfo = {
  level: number;
  text: string;
  id: string;
  index: number;
  element: HTMLElement;
};
```

**原因**：`path` 已作为 `headingsMap` 的 key，无需重复存储

---



## 三、功能实现与重构详解

本章节整合了原有的“需要修改的方法”和“功能需求与函数调用链路”，以功能为视角，详述重构方案。

### 功能1：文档加载时初始化思维导图

**用户场景**：打开包含标题的 Markdown 文档。

**需求链路与重构方案**：

1.  **`_update()` - 主更新流程**
    *   **调用 `_getDocumentHeadings()`**：提取文档所有标题，构建 `HeadingInfo` 对象。此时，在 `headingsMap` 中使用临时 key（如 `temp-0`, `temp-1`...）进行存储。
    *   **调用 `transformer.transform(markdown)`**：将 Markdown 文本转换为 `IPureNode` 树形数据。
    *   **删除 `_addNodePath()` 调用**：废弃手动构建路径的逻辑。
    *   **调用 `markmap.setData(root)`**：渲染思维导图。`markmap-view` 在此步骤中会自动为每个节点生成包含 `state.path` 的 `INode`。
    *   **调用 `_syncHeadingsWithNodes(root)`**：
        *   **重构此方法**：遍历 `INode` 树，获取 markmap 生成的 `state.path`。
        *   将 `headingsMap` 中的临时 key 替换为真实的 `state.path`。
        *   **新增**：填充 `elementToPathMap` 映射（`HTMLElement` -> `state.path`）。
    *   **调用 `_attachNodeClickListeners()`**：为渲染好的 SVG 节点绑定点击事件。

### 功能2：点击思维导图节点跳转到文档标题

**用户场景**：点击思维导图中的某个节点。

**需求链路与重构方案**：

1.  **`_attachNodeClickListeners()` - 捕获点击事件**
2.  **`_scrollToHeadingByNode(nodeEl)` - 处理节点跳转**
    *   **简化此方法**：从 `nodeEl.__data__` 中直接获取 `state.path`。
    *   使用 `state.path` 作为 key，在 `headingsMap` 中查找对应的 `HeadingInfo`。
3.  **`_scrollToElement(heading.element)` - 滚动到标题位置**

**数据流**: `SVG 节点` → `state.path` → `headingsMap` → `HTMLElement` → 滚动定位。

### 功能3：文档滚动时高亮当前标题对应的思维导图节点

**用户场景**：在文档中滚动浏览。

**需求链路与重构方案**：

1.  **`_onScroll()` - 滚动事件处理（防抖）**
2.  **`_getCurrentVisibleHeading()` - 查找当前可见标题**
    *   **重构此方法**：仅需返回第一个可见的标题 `HTMLElement`。
3.  **`elementToPathMap.get(headingElement)` - 获取标题的 `state.path`**
    *   利用新建的 `elementToPathMap` 实现 O(1) 复杂度的快速查找。
4.  **`_findDOMNodeByStatePath(path)` - 查找对应的 SVG 节点**
    *   **重构/重命名**：原 `_findNodeByPath` 重命名为此，通过 `querySelector(\"[data-path=\"${path}\"]\")` 查找。
5.  **`_highlightNode(nodeEl)` - 高亮节点**

**数据流**: `HTMLElement` → `elementToPathMap` → `state.path` → `SVG DOM 节点` → 高亮样式。

### 功能4：自动适应视图（聚焦当前标题）

**用户场景**：点击"适应视图"按钮或滚动到新标题。

**需求链路与重构方案**：

1.  **`_fitToView()` - 适应视图主流程**
    *   **重构此方法**：获取当前标题的 `HTMLElement`。
2.  **`_findNodeByHeading(headingElement)` - 查找对应的数据节点**
    *   **新增此方法**：通过 `elementToPathMap` 获取 `state.path`，再调用 `_findNodeByStatePath()` 在数据树中找到对应的 `INode` 对象。
3.  **`_ensureNodeVisible(targetNode)` - 确保节点可见**
    *   **重构此方法**：这是本次重构的关键。接收 `targetNode` 作为参数。
    *   **调用 `_getAncestorPaths(targetNode.state.path)`**：
        *   **新增此方法**：根据 `"0.1.3"` 计算出所有祖先路径 `["0", "0.1"]`。
    *   遍历祖先路径，找到对应的祖先 `INode`。
    *   检查祖先节点的 `state.fold` 状态，如果为 `1` (折叠)，则调用 `await markmap.toggleNode(ancestorNode)` 将其展开。
4.  **`_panAndZoomToNode(targetNode)` - 平移和缩放到目标节点**

**数据流**: `HTMLElement` → `elementToPathMap` → `state.path` → `INode` → 祖先展开 → 视图聚焦。

### 功能5：文档内容实时更新

**用户场景**：用户编辑文档，添加/删除/修改标题。

**需求链路与重构方案**：

1.  **`MutationObserver` 触发 `_onContentChange()`**
2.  **`_getDocumentHeadings()` - 重新提取标题**
3.  **`_getHeadingsHash()` - 计算标题哈希**
    *   **简化此方法**：使用标题的 `level + text + index` 生成哈希，不再依赖 `path`。
4.  **`transformer.transform()` -> `_syncHeadingsWithNodes()` -> `markmap.setData()`**
    *   调用 `setData()` 更新思维导图，Markmap 会自动保持大部分节点的折叠状态和视图位置。

### 功能6：节点折叠/展开

**用户场景**：点击思维导图节点的折叠按钮。

**需求链路与重构方案**：

*   此功能主要由 Markmap 内部自动处理。
*   我们的 `_ensureNodeVisible()` 方法将通过调用 `markmap.toggleNode()` 来利用此功能，以确保在聚焦节点前，其所有祖先都处于展开状态。







## 八、类型使用规范

### 导入类型
```typescript
import { INode } from 'markmap-common';
```

### 方法签名中使用 INode
所有处理 markmap 节点的方法应使用 `INode` 类型，而不是 `any`：

```typescript
// ✅ 正确
private _syncHeadingsWithNodes(node: INode, index = { current: 0 }): void

// ❌ 错误
private _syncHeadingsWithNodes(node: any, index = { current: 0 }): void
```

**需要修改类型的方法：**
- `_syncHeadingsWithNodes(node: INode, ...)`
- `_ensureNodeVisible(targetNode: INode): Promise<void>`
- `_findNodeByStatePath(targetPath: string): INode | null`
- `_findNodeByHeading(headingElement: HTMLElement): INode | null`

---

## 九、完整修改清单

### ❌ 必须删除
1. `_addNodePath` (第885行) - 删除整个方法

### 🔧 必须修改（类型/状态）
2. `HeadingInfo` - 删除 `path` 字段
3. `state` - 添加 `elementToPath: Map<HTMLElement, string>`
4. 文件顶部 - 添加 `import { INode } from 'markmap-common'`

### 🔄 必须修改（方法）
5. `_update` - 删除 `this._addNodePath(root)` 调用
6. `_getDocumentHeadings` - 删除 `path` 字段初始化
7. `_syncHeadingsWithNodes` - 使用 `node.state.path`，更新 `elementToPath`，参数改为 `INode`
8. `_scrollToHeadingByNode` - 使用 `nodeData.state.path`
9. `_getHeadingsHash` - 使用 `index` 代替 `path`

### 🔨 必须重构
10. `_getCurrentVisibleHeading` - 使用 `elementToPath` 获取 `state.path`
11. `_ensureNodeVisible` - 通过 `state.path` 计算祖先，参数改为 `INode`，返回 `Promise<void>`
12. `_fitToView` - 适配新的方法名和逻辑

### 🏷️ 必须重命名
13. `_findNodeByPath` → `_findDOMNodeByStatePath`
14. `_findDataNodeByPath` → `_findNodeByStatePath`，返回类型改为 `INode | null`

### ➕ 必须新增
15. `_getAncestorPaths(path: string): string[]`
16. `_findNodeByHeading(element: HTMLElement): INode | null`

**总计**: 16处修改











## 十一、功能需求与函数调用链路

### 功能1：文档加载时初始化思维导图

**用户场景**：打开包含标题的 Markdown 文档

**需求链路**：
```
用户打开文档
  ↓
_update() - 主更新流程
  ↓
_getDocumentHeadings() - 提取文档所有标题
  │ └→ 遍历 h1-h6 元素，构建 HeadingInfo 对象
  │ └→ 使用临时 key（temp-0, temp-1...）存入 headingsMap
  ↓
transformer.transform(markdown) - 将 Markdown 转为树形数据
  │ └→ markmap-lib 解析标题层级，生成 INode 树
  ↓
_syncHeadingsWithNodes(root) - 同步标题与节点映射
  │ └→ 遍历 INode 树，获取 markmap 生成的 state.path
  │ └→ 将临时 key 替换为 state.path
  │ └→ 更新 elementToPath 映射（element → state.path）
  ↓
markmap.setData(root) - 渲染思维导图
  │ └→ markmap-view 自动生成 state.id 和 state.path
  │ └→ 绘制 SVG 节点，添加 data-path 属性
  ↓
_attachNodeClickListeners() - 绑定节点点击事件
  └→ 监听 SVG 节点点击，触发跳转功能
```

**关键函数职责**：
- `_getDocumentHeadings()`：提取文档标题，建立初始映射（临时 key）
- `_syncHeadingsWithNodes()`：将临时 key 替换为 markmap 的 state.path
- `_attachNodeClickListeners()`：为思维导图节点绑定交互事件

---

### 功能2：点击思维导图节点跳转到文档标题

**用户场景**：点击思维导图中的某个节点

**需求链路**：
```
用户点击思维导图节点
  ↓
_attachNodeClickListeners() - 捕获点击事件
  ↓
_scrollToHeadingByNode(nodeEl) - 处理节点跳转
  │ └→ 从 nodeEl.__data__ 获取 state.path
  │ └→ 通过 headingsMap.get(state.path) 查找对应标题
  ↓
_scrollToElement(heading.element) - 滚动到标题位置
  └→ 使用 scrollIntoView 或 Typora API 定位
```

**关键函数职责**：
- `_scrollToHeadingByNode()`：根据 state.path 查找标题并跳转
- `_scrollToElement()`：执行实际的滚动操作

**数据流**：
```
SVG 节点 → state.path → headingsMap → HTMLElement → 滚动定位
```

---

### 功能3：文档滚动时高亮当前标题对应的思维导图节点

**用户场景**：在文档中滚动浏览

**需求链路**：
```
用户滚动文档
  ↓
_onScroll() - 滚动事件处理（防抖）
  ↓
_getCurrentVisibleHeading() - 查找当前可见标题
  │ └→ 遍历所有标题元素，判断是否在视口内
  │ └→ 返回第一个可见的标题元素
  ↓
elementToPath.get(headingElement) - 获取标题的 state.path
  ↓
_findDOMNodeByStatePath(path) - 查找对应的 SVG 节点
  │ └→ 通过 querySelector(`[data-path="${path}"]`) 查找
  ↓
_highlightNode(nodeEl) - 高亮节点
  └→ 添加 CSS 类或修改样式
```

**关键函数职责**：
- `_getCurrentVisibleHeading()`：检测当前可见的文档标题
- `_findDOMNodeByStatePath()`：通过 state.path 查找 SVG DOM 节点
- `_highlightNode()`：视觉上高亮当前节点

**数据流**：
```
HTMLElement → elementToPath → state.path → SVG DOM 节点 → 高亮样式
```

---

### 功能4：自动适应视图（聚焦当前标题）

**用户场景**：点击"适应视图"按钮或滚动到新标题

**需求链路**：
```
用户触发适应视图
  ↓
_fitToView() - 适应视图主流程
  ↓
_getCurrentVisibleHeading() - 获取当前标题
  ↓
_findNodeByHeading(headingElement) - 查找对应的数据节点
  │ └→ 通过 elementToPath 获取 state.path
  │ └→ 调用 _findNodeByStatePath() 在数据树中查找
  ↓
_ensureNodeVisible(targetNode) - 确保节点可见
  │ └→ _getAncestorPaths(targetNode.state.path) - 计算祖先路径
  │     └→ 例如 "0.1.3" → ["0", "0.1"]
  │ └→ 遍历祖先路径，检查折叠状态
  │ └→ 如果祖先被折叠，调用 markmap.toggleNode() 展开
  │ └→ 等待 DOM 更新（requestAnimationFrame）
  ↓
_panAndZoomToNode(targetNode) - 平移和缩放到目标节点
  │ └→ _calculateOptimalScale() - 计算最佳缩放比例
  │ └→ 应用 SVG transform 动画
  └→ 完成聚焦
```

**关键函数职责**：
- `_fitToView()`：协调整个适应视图流程
- `_findNodeByHeading()`：从标题元素找到数据节点（INode）
- `_ensureNodeVisible()`：展开所有祖先节点，确保目标可见
- `_getAncestorPaths()`：从 state.path 计算祖先路径列表
- `_findNodeByStatePath()`：在数据树中通过 state.path 查找节点
- `_panAndZoomToNode()`：执行平滑的视图动画

**数据流**：
```
HTMLElement → elementToPath → state.path → INode → 祖先展开 → 视图聚焦
```

---

### 功能5：文档内容实时更新

**用户场景**：用户编辑文档，添加/删除/修改标题

**需求链路**：
```
用户编辑文档
  ↓
MutationObserver 触发
  ↓
_onContentChange() - 内容变化处理（防抖）
  ↓
_getDocumentHeadings() - 重新提取标题
  │ └→ 生成新的 headingsMap（临时 key）
  ↓
_getHeadingsHash() - 计算标题哈希
  │ └→ 使用标题的 level + text + index 生成哈希
  │ └→ 与上次哈希对比，判断是否真的变化
  ↓
如果哈希不同：
  ↓
  transformer.transform(markdown) - 重新解析
  ↓
  _syncHeadingsWithNodes(root) - 重新同步映射
  ↓
  markmap.setData(root) - 更新思维导图
    └→ markmap 保持现有的折叠状态和视图位置
```

**关键函数职责**：
- `_onContentChange()`：监听文档变化，触发更新
- `_getHeadingsHash()`：避免不必要的重新渲染
- `markmap.setData()`：增量更新，保持用户状态

**优化点**：
- 使用哈希对比避免频繁重绘
- `setData()` 保持折叠状态，用户体验更好

---

### 功能6：节点折叠/展开

**用户场景**：点击思维导图节点的折叠按钮

**需求链路**：
```
用户点击折叠按钮
  ↓
markmap 内部处理（自动）
  │ └→ 更新 node.payload.fold 状态
  │ └→ 重新渲染子节点
  ↓
（如果需要手动控制）
  ↓
markmap.toggleNode(node) - 切换折叠状态
  └→ markmap 自动更新 DOM
```

**关键函数职责**：
- `markmap.toggleNode()`：切换节点折叠状态（markmap-view 提供）
- `_ensureNodeVisible()` 中使用：展开被折叠的祖先节点

**注意**：
- 折叠状态由 markmap 自动管理，存储在 `node.payload.fold`
- 不需要手动操作 DOM，调用 API 即可

---

## 十二、核心数据结构关系图

```
┌─────────────────────────────────────────────────────────────┐
│                        文档标题层                              │
│  <h1>第一章</h1>  <h2>第一节</h2>  <h3>第一小节</h3>           │
└────────────┬────────────────────────────────────────────────┘
             │ _getDocumentHeadings()
             ↓
┌─────────────────────────────────────────────────────────────┐
│                    headingsMap (Map)                         │
│  key: state.path (如 "0.1.3")                                │
│  value: HeadingInfo {                                        │
│    level: 3,                                                 │
│    text: "第一小节",                                          │
│    element: HTMLElement,                                     │
│    id: "heading-3",                                          │
│    index: 2                                                  │
│  }                                                           │
└────────────┬────────────────────────────────────────────────┘
             │
             ↓
┌─────────────────────────────────────────────────────────────┐
│                 elementToPath (Map)                          │
│  key: HTMLElement (标题元素)                                  │
│  value: state.path (如 "0.1.3")                              │
│  用途：从标题元素快速查找 state.path                           │
└────────────┬────────────────────────────────────────────────┘
             │
             ↓
┌─────────────────────────────────────────────────────────────┐
│                    INode 数据树                               │
│  {                                                           │
│    content: "<h3>第一小节</h3>",                              │
│    state: {                                                  │
│      id: 3,                                                  │
│      path: "0.1.3",  ← markmap 自动生成                      │
│      depth: 2                                                │
│    },                                                        │
│    payload: { fold: 0 },                                    │
│    children: [...]                                           │
│  }                                                           │
└────────────┬────────────────────────────────────────────────┘
             │ markmap.setData()
             ↓
┌─────────────────────────────────────────────────────────────┐
│                    SVG DOM 节点                               │
│  <g data-path="0.1.3" class="markmap-node">                 │
│    <circle />                                                │
│    <text>第一小节</text>                                      │
│  </g>                                                        │
└─────────────────────────────────────────────────────────────┘
```

**数据流向**：
1. **初始化**：HTML 标题 → headingsMap + elementToPath → INode 树 → SVG
2. **点击跳转**：SVG 节点 → state.path → headingsMap → HTML 标题
3. **滚动高亮**：HTML 标题 → elementToPath → state.path → SVG 节点
4. **适应视图**：HTML 标题 → elementToPath → state.path → INode → 展开祖先 → 聚焦

---

## 十三、重构前后对比

### 对比1：节点标识方式

| 方面 | 重构前 | 重构后 |
|------|--------|--------|
| 标识符 | 自定义文本路径（"第一章\n第一节"） | markmap 的 state.path（"0.1.3"） |
| 生成方式 | 手动拼接标题文本 | markmap-view 自动生成 |
| 唯一性 | 标题重名时会冲突 | 基于节点 ID，绝对唯一 |
| 维护成本 | 需要手动维护路径逻辑 | 零维护，由 markmap 管理 |

### 对比2：查找节点效率

| 操作 | 重构前 | 重构后 |
|------|--------|--------|
| 查找数据节点 | 遍历树，逐层匹配文本 | 通过 state.path 直接定位 |
| 查找 DOM 节点 | 遍历 SVG，匹配自定义属性 | querySelector(`[data-path="${path}"]`) |
| 时间复杂度 | O(n) | O(1) 或 O(log n) |

### 对比3：代码行数

| 模块 | 重构前 | 重构后 | 减少 |
|------|--------|--------|------|
| `_addNodePath` | ~30 行 | 删除 | -30 |
| `_syncHeadingsWithNodes` | ~25 行 | ~15 行 | -10 |
| `_ensureNodeVisible` | ~40 行 | ~25 行 | -15 |
| 新增辅助方法 | 0 | ~15 行 | +15 |
| **总计** | ~95 行 | ~55 行 | **-40 行** |

---

## 十四、关键技术决策

### 决策1：为什么使用 state.path 而不是自定义路径？

**理由**：
1. **官方支持**：state.path 是 markmap-view 的标准字段，有稳定的生成逻辑
2. **唯一性保证**：基于自增 ID，不会因标题重名而冲突
3. **DOM 同步**：markmap 自动将 state.path 写入 `data-path` 属性，便于查询
4. **零维护成本**：不需要手动构建和更新路径

### 决策2：为什么需要 elementToPath 映射？

**理由**：
1. **双向查找**：
  - 从标题到节点：`elementToPath.get(element)` → state.path → INode
  - 从节点到标题：state.path → `headingsMap.get(path)` → element
2. **性能优化**：避免每次都遍历 headingsMap 查找元素
3. **代码清晰**：明确表达"元素到路径"的映射关系

### 决策3：为什么 _ensureNodeVisible 返回 Promise？

**理由**：
1. **异步展开**：调用 `markmap.toggleNode()` 后，DOM 更新是异步的
2. **链式操作**：展开节点后需要等待 DOM 更新，才能执行后续的聚焦操作
3. **避免竞态**：使用 `await` 确保操作顺序正确

```typescript
// 正确的调用方式
await this._ensureNodeVisible(targetNode);
this._panAndZoomToNode(targetNode);  // 此时节点已展开
```



---

## 十六、迁移检查清单

### 代码修改
- [ ] 删除 `_addNodePath` 方法
- [ ] 修改 `HeadingInfo` 类型定义
- [ ] 添加 `elementToPath: Map<HTMLElement, string>` 到 state
- [ ] 导入 `INode` 类型
- [ ] 修改 `_syncHeadingsWithNodes` 使用 state.path
- [ ] 修改 `_scrollToHeadingByNode` 使用 state.path
- [ ] 重构 `_ensureNodeVisible` 使用 `_getAncestorPaths`
- [ ] 重命名 `_findNodeByPath` → `_findDOMNodeByStatePath`
- [ ] 重命名 `_findDataNodeByPath` → `_findNodeByStatePath`
- [ ] 新增 `_getAncestorPaths` 方法
- [ ] 新增 `_findNodeByHeading` 方法
- [ ] 更新 `_fitToView` 适配新逻辑

### 测试验证
- [ ] 点击节点跳转功能正常
- [ ] 滚动高亮功能正常
- [ ] 适应视图功能正常
- [ ] 实时更新功能正常
- [ ] 标题重名场景测试通过
- [ ] 深层嵌套场景测试通过
- [ ] 边界情况测试通过

### 文档更新
- [ ] 更新 API 文档说明 state.path 的使用
- [ ] 更新架构图，标注数据流向
- [ ] 记录重构决策和理由

---

## 十七、常见问题 FAQ

### Q1：为什么不直接使用 node.state.id 作为标识符？

**A**：`state.id` 是全局自增的，无法表达节点的层级关系。而 `state.path` 包含了完整的祖先信息（如 "0.1.3" 表示根节点 → 第1个子节点 → 第3个孙子节点），便于计算祖先路径。

### Q2：如果用户修改标题，state.path 会变化吗？

**A**：不会。`state.path` 基于节点在树中的位置，只要位置不变，path 就不变。修改标题文本只会更新 `node.content`，不影响 `state.path`。

### Q3：如果用户删除中间的标题，其他节点的 state.path 会变吗？

**A**：会。因为 `state.id` 是按遍历顺序自增的，删除节点后，后续节点的 ID 会前移。但这不影响功能，因为我们在每次更新时都会重新同步 `headingsMap`。

### Q4：为什么不使用 node.state.key 作为标识符？

**A**：`state.key` 是基于内容的哈希，虽然唯一，但无法表达层级关系，也不方便计算祖先路径。而且 markmap 没有将 `key` 写入 DOM 属性，不便于查询。

### Q5：重构后性能会提升吗？

**A**：会。主要体现在：
1. 查找节点从 O(n) 降到 O(1)
2. 不需要手动构建路径，减少计算量
3. 代码更简洁，减少 bug 风险

